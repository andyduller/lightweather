#!/usr/bin/env ruby

require 'sqlite3'
require 'optparse'

def dbInit()
  # Try to setup up the sqlite package
  if File::exists?("weather.db")
    db = SQLite3::Database.new("weather.db")
  else
    db = SQLite3::Database.new("weather.db")
    # timestamp is the Unix date i.e. seconds since 1970-01-01 00:00:00 UTC
    db.execute("CREATE TABLE data (timestamp INTEGER PRIMARY KEY, \
                                abspressure FLOAT, \
                                windspeed FLOAT, \
                                winddir INTEGER, \
                                rainfall FLOAT, \
                                indoortemp FLOAT, \
                                outdoortemp FLOAT, \
                                indoorhumid INTEGER, \
                                outdoorhumid INTEGER)")
  end
  return db
end

def addDbEntry(db, tstamp, pres, wspeed, wdir, rain, itemp, otemp, ihumid, ohumid)
  # See if this timestamp already present, if so, then check if data is
  # identical, give warning about this. If not present just add the entry.
  timestamp = db.execute("SELECT timestamp FROM data WHERE timestamp=" + tstamp.to_s)
  if timestamp.empty?
    db.execute("INSERT INTO data VALUES (#{tstamp}, #{pres}, #{wspeed}, #{wdir},
               #{rain}, #{itemp}, #{otemp}, #{ihumid}, #{ohumid})")
  else
    db.results_as_hash = true
    retVal = db.execute("SELECT * FROM data WHERE timestamp=#{tstamp}")
    values = retVal[0] 
    if values["abspressure"].to_s != pres
      puts "Diff abspressure #{values["abspressure"]} #{pres}"
    end
    if values["windspeed"].to_s != wspeed
      puts "Diff windspeed #{values["windspeed"]} #{wspeed}"
    end
    if values["winddir"] != wdir
      puts "Diff winddir #{values["winddir"]} #{wdir}"
    end
    if values["rainfall"].to_s != rain
      puts "Diff rainfall #{values["rainfall"]} #{rain}"
    end
    if values["indoortemp"].to_s != itemp
      puts "Diff indoortemp #{values["indoortemp"]} #{itemp}"
    end
    if values["outdoortemp"].to_s != otemp
      puts "Diff outdoortemp #{values["outdoortemp"]} #{otemp}"
    end
    if values["indoorhumid"] != ihumid
      puts "Diff indoorhumid #{values["indoorhumid"]} #{ihumid}"
    end
    if values["outdoorhumid"] != ohumid
      puts "Diff outdoorhumid #{values["outdoorhumid"]} #{ohumid}"
    end
  end
end

def showDbRanges(db)
  start = 0
  nextts = 0
  count = 0
  db.results_as_hash = true
  rows = db.execute("SELECT * FROM data ORDER BY timestamp")
  rows.each do |values|
    count = count + 1
    ts = values["timestamp"]
    if start == 0
      start = ts
      nextts = ts
    end
    if ts == nextts
      # Still part of this block
      nextts = nextts + 3600
    else
      puts "#{seconds2date(start)} -> #{seconds2date(nextts - 3600)}"
      puts "Gap: #{(ts - nextts)/3600}"
      start = ts
      nextts = ts + 3600
    end
  end

  # Output the last range
  puts "#{seconds2date(start)} -> #{seconds2date(nextts - 3600)}"
  puts "#{count} timestamps"
 end


# outdoortemp = 81.1 means no connection
# windspeed = 51.0 means no connection
# outdoorhumid = 110 means no connection
def showDb(db, type)
  start = 0
  validTypes = ["abspressure", "windspeed", "winddir", "rainfall", "indoortemp", "outdoortemp", "indoorhumid", "outdoorhumid"]
  unless validTypes.any? { |x| x == type }
    puts "#{type} is not a valid datatype. Expected one of #{validTypes.join(", ")}"
    exit(1)
  end
  count = 0
  db.results_as_hash = true
  rows = db.execute("SELECT * FROM data ORDER BY timestamp")
  if type == "rainfall"
    previous = 0
    rows.each do |values|
      current = values["rainfall"]
      diff = (current - previous).abs
      if diff > 300
        diff = 0
      end
      previous = current
      puts "#{values["timestamp"]} #{"%.1f" % diff} #{values["rainfall"]} #{seconds2date(values["timestamp"])}"
    end
  else
    rows.each do |values|
      puts "#{values["timestamp"]} #{values[type.to_s]} #{seconds2date(values["timestamp"])}"
    end
  end
end
    
def timestamp2unix(t)
  return t - ((70 * 365 + 17) * 86400)
end

def unix2timestamp(t)
  return t + ((70 * 365 + 17) * 86400)
end

def seconds2date(s)
  %x{date -d @#{s.to_s}}.chomp!
end
    
def readWeatherFile(db, binfile)
  fp = open(binfile, "rb")
  count = 0
  
  while !fp.eof()
    type = fp.read(4).unpack("L")
    if type[0] == 1
      count = count + 1
      timestamp, pressure, windspeed, winddir, rain, intemp, outtemp,
        inhumidity, outhumidity = fp.read(32).unpack("LffLfffSS")
      # Change timestamp to be unix standard
      timestamp = timestamp2unix(timestamp)
      addDbEntry(db, timestamp,
                 "%.1f" % pressure,
                 "%.1f" % windspeed,
                 winddir,
                 "%.4f" % rain,
                 "%.1f" % intemp,
                 "%.1f" % outtemp,
                 inhumidity,
                 outhumidity)
    else
      u1, u2, u3, rows, timestamp1, timestamp2 = fp.read(24).unpack("LLLLLL")
      puts "#{type[0]} #{u1} #{u2} #{u3}"
      ts1 = timestamp2unix(timestamp1)
      ts2 = timestamp2unix(timestamp2)
      break
    end
  end
    
  fp.close()
end

class Array
  alias :prepend :unshift
end

def writeWeatherFile(db, binfile)
  fp = open(binfile, "wb")
  timestamp1 = 0
  timestamp2 = 0
  
  rows = db.execute("SELECT * FROM data")
  rows.each_with_index do |row, idx|
    if idx == 0
      timestamp1 = row[0]
    end
    timestamp2 = row[0]
    row[0] = unix2timestamp(row[0])
    # Add the type (always 1 for normal data) as the first element of the row
    row.prepend(1)
    fp.write(row.pack("LLffLfffSS"))
  end

  ts1 = unix2timestamp(timestamp1)
  ts2 = unix2timestamp(timestamp2)
  # The contents of these first 4 values is not understood. The first and
  # fourth seem to remain constant.
  fp.write([558065031, 1160206492, 655.27001953125, 0, rows.length,
            ts1, ts2].pack("LLfLLLL"))
  fp.close
end

opts = OptionParser.new do |opts|
  opts.on("-a", "--add2db DATAFILE") do |datafile|
    db = dbInit
    readWeatherFile(db, datafile)
    showDbRanges(db)
  end
  opts.on("-w", "--writedb DATAFILE") do |datafile|
    db = dbInit
    writeWeatherFile(db, datafile)
    showDbRanges(db)
  end
  opts.on("-s", "--showdb [DATATYPE]") do |datatype|
    db = dbInit
    if datatype.nil?
      showDbRanges(db)
    else
      showDb(db, datatype)
    end
  end
  opts.on_tail("-h", "--help") do
    puts opts
    exit
  end
end

opts.parse!(ARGV)
exit
